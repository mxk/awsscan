// +build codegen

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"sort"
	"strings"
	"text/template"
	"unicode"

	"github.com/LuminalHQ/cloudcover/awsscan/scan"
	"github.com/aws/aws-sdk-go-v2/private/model/api"
)

const usage = `
Usage: %s [options] <out-dir> <service> [<service> ...]

Generates service scanner source code for each AWS service and writes the output
to out-dir. If out-dir is "-", the output is written to stdout. Services can be
specified by their package name (e.g. "iam") or as paths to existing source
files. The service name is extracted from the file name, but the output is still
written to out-dir.

Options:
`

var modelsDir = filepath.Join(findSDK(), "models")
var tplDir = "tpl"

func init() {
	flag.Usage = func() {
		bin := filepath.Base(os.Args[0])
		fmt.Fprintf(flag.CommandLine.Output(), usage[1:], bin)
		flag.PrintDefaults()
	}
	flag.StringVar(&modelsDir, "models", modelsDir, "SDK models `dir`ectory")
	if flag.Parse(); flag.NArg() < 2 {
		flag.Usage()
		os.Exit(2)
	}
	cwd, err := os.Getwd()
	must(err)
	must(os.Chdir(modelsDir))
	must(api.Bootstrap())
	must(os.Chdir(cwd))
}

func main() {
	outDir := flag.Arg(0)
	if outDir != "-" {
		must(os.MkdirAll(outDir, 0755))
	}
	rc := 0
	for _, name := range svcNames(flag.Args()[1:]) {
		fmt.Fprintln(os.Stderr, "==>", name)
		if buf, err := gen(name); err != nil {
			fmt.Fprintln(os.Stderr, err)
			rc = 1
		} else if outDir == "-" {
			os.Stdout.Write(buf)
		} else {
			dst := filepath.Join(outDir, name+".go")
			if err = ioutil.WriteFile(dst, buf, 0644); err != nil {
				fmt.Fprintln(os.Stderr, err)
				rc = 1
			}
		}
	}
	os.Exit(rc)
}

func svcNames(spec []string) (services []string) {
	var err error
	for _, s := range spec {
		names := []string{s}
		if runtime.GOOS == "windows" && strings.ContainsAny(s, "*?[") {
			names, err = filepath.Glob(s)
			must(err)
		}
		for _, name := range names {
			name = filepath.Base(name)
			if i := strings.IndexByte(name, '.'); i != -1 {
				name = name[:i]
			}
			services = append(services, name)
		}
	}
	return
}

func gen(svcName string) ([]byte, error) {
	tpl, err := serviceTpl.Clone()
	if err != nil {
		return nil, err
	}
	svc, err := loadService(svcName)
	if err != nil {
		return nil, err
	}
	buf := bytes.NewBuffer(make([]byte, 0, 4096))
	if err := tpl.Execute(buf, svc); err != nil {
		return nil, err
	}
	src, err := format.Source(buf.Bytes())
	if err != nil {
		err = fmt.Errorf("Source:\n%s\nError: %v\n", buf.Bytes(), err)
	}
	return src, err
}

var serviceTpl = template.Must(template.New("MAIN").Funcs(
	template.FuncMap{"initials": initials},
).Parse(`
// Code generated by svcgen. Do not edit!

package service

import (
	"{{.ScanPkg}}"
	"github.com/aws/aws-sdk-go-v2/service/{{.Name}}"
)

type {{.Name}}Svc struct{}

func init() { scan.Register({{.Name}}Svc{}) }

func ({{.Name}}Svc) Name() string         { return {{.Name}}.ServiceName }
func ({{.Name}}Svc) NewFunc() interface{} { return {{.Name}}.New }
func ({{.Name}}Svc) Roots() []interface{} {
	return []interface{}{
	{{- range .Roots}}
		[]{{.}}{nil},
	{{- end}}
	}
}
`[1:]))

var scanPkg = reflect.TypeOf((*scan.Service)(nil)).Elem().PkgPath()
var scanAPI = map[string]bool{
	"Describe": true,
	"Get":      true,
	"List":     true,
}

type Service struct {
	api.API
	Name string
}

func loadService(name string) (svc *Service, err error) {
	spec := filepath.Join(modelsDir, "apis", name, "*", "api-2.json")
	matches, err := filepath.Glob(spec)
	if err != nil {
		return nil, err
	}
	if len(matches) == 0 {
		return nil, fmt.Errorf("api-2.json not found via %q", spec)
	}
	svc = new(Service)
	svc.Attach(matches[len(matches)-1])
	svc.Setup()
	svc.Name = svc.PackageName()
	return svc, nil
}

func (s *Service) ScanPkg() string {
	return scanPkg
}

func (s *Service) Roots() []string {
	roots := make([]string, 0, 8)
	for _, op := range s.Operations {
		if !op.Deprecated && scanAPI[words(op.ExportedName)[0]] &&
			len(op.InputRef.Shape.Required) == 0 {
			roots = append(roots, op.InputRef.Shape.GoTypeWithPkgName())
		}
	}
	sort.Strings(roots)
	return roots
}

func words(id string) []string {
	words := make([]string, 0, 4)
	for id != "" {
		u := strings.IndexFunc(id[1:], unicode.IsUpper) + 1
		l := strings.IndexFunc(id[1:], unicode.IsLower) + 1
		if u == 0 || l == 0 {
			words, id = append(words, id), ""
		} else if l < u {
			words, id = append(words, id[:u]), id[u:]
		} else {
			words, id = append(words, id[:l-1]), id[l-1:]
		}
	}
	return words
}

func initials(id string) string {
	var buf [16]byte
	b := buf[:0]
	for _, word := range words(id) {
		b = append(b, byte(unicode.ToLower(rune(word[0]))))
	}
	return string(b)
}

func findSDK() string {
	fn := runtime.FuncForPC(reflect.ValueOf(api.Bootstrap).Pointer())
	path, _ := fn.FileLine(fn.Entry())
	if !filepath.IsAbs(path) {
		panic("svcgen: invalid path to api.go: " + path)
	}
	for filepath.Base(path) != "aws-sdk-go-v2" {
		prev := path
		if path = filepath.Dir(path); path == prev {
			panic("svcgen: aws-sdk-go-v2 directory not found")
		}
	}
	return path
}

func must(err error) {
	if err != nil {
		panic(err)
	}
}
